#!/bin/sh
# shellcheck disable=SC2086,SC2015,SC2166
# SC2015 - && is used with :; / ;:;
# SC2166 - -a works in any real shell

shrealpath() { # better to not use realpath as some posix shells may not use the function
  [ "$lsl"  ] || depsetup
  og="${PWD}"
  [ "${1##/*}" != "" ] && { # check if not already full path - /ex/ex2##/* = ""
    cpath="${1%/*}"; [ -e "$cpath" ] || { printf '%s is not a file/folder!! Falling back..' "$cpath"; return 1;}
    {
      if [ -d "$cpath" -a -x "$cpath" ]; then
        cd "${cpath}" || return 1
        rpath="$(pwd -P)/${1##*/}"
        [ -d "$rpath" ] && { cd "$rpath"; rpath="$(pwd -P)";}
      elif [ -f "$cpath" ]; then # fallback to ls -l if file
        unalias -a # incase ls is an alias
        IFS=" "; rpath=$(${lsl:-ls -l} "${cpath}"); rpath=${rpath##*>}
      fi
      printf '%s\n' "${rpath}"
    }
  } || echo "$1"
  cd "$og" || return 1
}
shcat() {
   IFS=""; while read -r p || [ -n "$p" ]; do
      printf '%s\n' "$p"
    done <&0
}
dconf() {
  IFS=""
  if [ -e ./config ];then
    conf=./config
  elif [ -e ${XDG_CONFIG_HOME:-$HOME/.config}/linkcage/config ]; then
    conf="${XDG_CONFIG_HOME:-$HOME/.config}/linkcage/config"
  elif [ -e /etc/linkcage/config ];then
    conf="/etc/linkcage/config"
  fi
  [ "$1" ] && conf="${1}"
} # attempt to detect the config file location
# STDIN configs will be handled by the parser
depsetup() { # make sure all deps exist and match expected data
  has() {
    case "$(command -v $1 2>/dev/null)" in
      alias*|"") return 1
    esac
  }
  
  has ln || { echo "ln IS REQUIRED..."; exit 1; }
  has unlink && { unlink="unlink";:;} || {
    has rm || { unlink="rm -rf";:;} || {
      echo "unlink OR rm IS REQUIRED..."; exit 1
    :;}
  }  
  unset IFS; lsl=$(ls -l /dev/null); case "$lsl" in
    *"- root root"*"/dev/null") lsl="ls -l";;
    *) echo "ls -l does not match case... FAILING"; exit 1;;
  esac
}
confparse() {
  lparse() {#     - support `1 > 2` & `1>2`
    [ "$unlink" ] || depsetup
    p="${1}"
    r="${p##*>}"; [ "$r" = "$p" ] && r="${p##* >}" # right side
    l="${p%%>*}"; [ "$l" = "$p" ] && l="${p%% >*}" # left side
    # a < case should go here
    if [ -e "$r" -a ! -h "$r" ]; then # if $r is file and NOT a symlink
      rf="${r}" # realfile
      link="${l}" # where to/is link
    elif [ -e "$l" -a ! -h "$l" ]; then # versa above
      rf="${l}"
      link="${r}"
    else
      echo "WARNING: $p -- IS NOT A VALID CONF LINE" >&2
      return 1
    fi
    IFS=""
    [ -e "$link" ] && ${unlink} ${link} # unlink link file
    # still WIP
  }
  # [ "$conf" ] || { dconf "$1";} # could have use
  case "$conf" in
    "")
      while read -r p || [ -n "$p" ]; do
        lparse "$p"
      done<&0 ;; # STDIN case
    *)
      while read -r p || [ -n "$p" ]; do
        lparse "$p"
      done<"${conf}" ;;
  esac
}
